import pylibmagic
import magic
from pycti import OpenCTIApiClient
import argparse
from datetime import datetime
import urllib3

#-------------------------------------------------------------
# This code pushes domains to the OpenCTI server and creates an
# "indicates" relationship between the domain and some known
# malware. In order to help keep malware naming straight you have
# to provide the name of malware that already exists in the OpenCTI
# instance and the script will make suggestions based on the name
# you provide. If you need a new name added contact the admin.
#
# You can also use this example and the information/examples in
# the links below to create your own scripts.
#
# More generic examples can be found at:
# https://github.com/OpenCTI-Platform/client-python/tree/1242f96edc641bf8010ad7484215b1841a758892/examples
#
# Information on STIX:
# https://docs.oasis-open.org/cti/stix/v2.1/csprd01/stix-v2.1-csprd01.html

#----------------------------------------------
# get this information from the admin
api_url = ""
api_token = ""

# keeps the output clean
urllib3.disable_warnings()

#---------------------------------------------
# It's the main function... this is where we start
def main():
    # OpenCTI initialization
    opencti_api_client = OpenCTIApiClient(api_url, api_token)
    # Parse the command line arguments
    args = getargs()
    domains = []

    # file should be of the form (author is basically the source)
    # domain,malware,author,confidence
    if args['file']:
        lines = open(args['file']).readlines()
        for l in lines:
            f = l.split(',')
            if len(f) != 4:
                print('Why you giving me the wrong data? I want <domain>,<malware>,<author>,<confidence>')
                return
            domains.append({'domain':f[0], 'malware': f[1], 'author':f[2], 'confidence':f[3]})
    else:
        # bail if they don't provide a domain
        if not args['domain']:
            print('We sort of need a domain here... try again with feeling')
            return
        domains.append({'domain':args['domain'], 'malware': args['malware'], 'author':args['author'], 'confidence':args['confidence']})
    
    for d in domains:
        # retrieve or create the domain
        domain_observable = get_domain_observable(opencti_api_client, d['domain'],d['author'],d['malware'],d['confidence'])
        # retrieve the malware or recommend the user have it created in db
        malware = get_malware(opencti_api_client,d['malware'])

        # if we have a domain and malware create an indicator and relationship
        if malware != None:
            create_relationship(opencti_api_client,domain_observable,malware)

#----------------------------------------------
# Two modes of operation, either providing a single domain and malware name or
# a csv (todo). The submitter should provide an author, confidence and malware name.
# However, if no malware is provided it will default to a 'unknown' placeholder malware.
def getargs():
    parser = argparse.ArgumentParser(description='Send domain malware indicator to crypto community OpenCTI server. If you do not pass the malware name the domain will be associated with \'unknown\' malware. Please make sure you provide an author and confidence. Confidence will default to 50 if you do not.')
    parser.add_argument('-f','--file', help='Read domains from a csv file of format <domain>,<malware>,<author>,<confidence>', required=False)
    parser.add_argument('-d','--domain', help='Malicious domain to report', required=False)
    parser.add_argument('-m','--malware', help='The malware it indicates', required=False, default='unknown')
    parser.add_argument('-a','--author', help='Subitting org or individual (author)', required=True)
    parser.add_argument('-c','--confidence', help='Confidence in relationship from 0 to 100', required=False, default='50')

    args = vars(parser.parse_args())

    return args

#--------------------------------
# You have a domain and some malware, create a relationship.
# In STIX the domain can stand alone as an observable, so we
# create an indicator for the domain that then establishes
# an 'indicates' relationship with the malware. It might
# seem overly complicated at first but trust the standard.
def create_relationship(opencti_api_client,domain,malware):
        
    # does a relationship already exist?
    found = False
    for i in domain['indicators']:
        # check if our domain is in the pattern
        if 'pattern' in i and domain['value'] in i['pattern']:
            print("An indicator for this domain already exists. Manually check the UI if the relationship it correct.")
            # technically a domain could indicate multiple malware, but
            # for this iteration let's keep it simple and just return.
            found = True

    
    # Assuming there isn't already an indicator create a new one
    if not found:
        # an indicator can be a complex pattern, here the indicator is
        # just the presence of the domain of interest
        indicator = opencti_api_client.indicator.create(
            name="{} associated with {}".format(domain['value'],malware['name']),
            description="{} associated with {}".format(domain['value'],malware['name']),
            pattern_type="stix",
            pattern="[domain-name:value = '{}']".format(domain['value']),
            x_opencti_main_observable_type="Domain-Name",
            valid_from=datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
        )

        # associate the indicator with the domain observable
        opencti_api_client.indicator.add_stix_cyber_observable(
            id=indicator["id"], stix_cyber_observable_id=domain["id"]
        )

        # create the relationship
        relation = opencti_api_client.stix_core_relationship.create(
            fromId=indicator["id"],
            toId=malware["id"],
            relationship_type="indicates",
            description="{} associated with {}".format(domain['value'],malware['name']),
            start_time=datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
            #stop_time=datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
        )

#----------------------------
# If this domain already exists in the db grab it, otherwise
# create it. Return a handle to a domain observable object.
def get_domain_observable(opencti_api_client, domain, author, malware, confidence):
    
    # search for the domain using filters
    observable = opencti_api_client.stix_cyber_observable.read(
        filters={
            "mode": "and",
            "filters": [{"key": "value", "values": [domain]}],
            "filterGroups": [],
        }
    )

    # didnt' find the domain, great create it!
    if observable == None:
        # Create domain observable
        opencti_api_client.stix_cyber_observable.create(
            observableData={
                "type": "domain-name",
                "value": domain,
                "x_opencti_description": "Domain submitted by {} associated with {}".format(author,malware),
                "x_opencti_score": int(confidence),
            }
        )

        # for some reason when you create the domain you don't get back all the
        # data, so create it then search for it
        observable = opencti_api_client.stix_cyber_observable.read(
        filters={
            "mode": "and",
            "filters": [{"key": "value", "values": [domain]}],
            "filterGroups": [],
        }
    )
    
    # this should always contain a value since if it doesn't exist we create it
    return observable

#------------------------
# If this malware already exists in the db grab it, otherwise
# make some suggestions to the user. The intent here is that
# they select a known malware name and to reduce the chance of
# having the same malware with slight variations in the name.
# If you need a malware added just ping the OpenCTI admin
def get_malware(opencti_api_client,malware_name):

    # these filters are pretty generic
    malware = opencti_api_client.malware.read(
        filters = {
            "mode": "and",
            "filters": [{"key": "name", "values": [malware_name]}],
            "filterGroups": [],
        }
    )
    
    # found an exact match, great return it!
    if not malware == None:
        return malware
    else:
        # try to find similar matches
        malwares = opencti_api_client.malware.list(search=malware_name)
        # lots of similar matches, return a list so the user can try again
        if len(malwares) > 1:
            print('More then one match, please be more specific. Possible matches:')
            for m in malwares:
                print(m['name'])
        # if there is just one match, maybe it's a typo or an alias, provide a recommendation
        elif len(malwares) == 1 and malwares[0]['name'] != malware_name:
            print('Found possible match, please use this name: {}'.format(malwares[0]['name']))
        else:
            # You're way off, nothing like that in the db
            print('No matches found for malware, contact your admin to have it added')

    return None

#----------------------
# Do people still do this in Python? I feel weird if I don't have a "main"
if __name__ == '__main__':
    main()
