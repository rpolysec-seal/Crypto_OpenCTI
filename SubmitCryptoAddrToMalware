import pylibmagic
import magic
from pycti import OpenCTIApiClient
import argparse
from datetime import datetime
import urllib3

#-------------------------------------------------------------
# This code pushes crypto addresses to the OpenCTI server and creates an
# "indicates" relationship between the crypto address and some known
# malware. In order to help keep malware naming straight you have
# to provide the name of malware that already exists in the OpenCTI
# instance and the script will make suggestions based on the name
# you provide. If you need a new name added contact the admin
#
# More generic examples can be found at:
# https://github.com/OpenCTI-Platform/client-python/tree/1242f96edc641bf8010ad7484215b1841a758892/examples
#
# Information on STIX:
# https://docs.oasis-open.org/cti/stix/v2.1/csprd01/stix-v2.1-csprd01.html

#----------------------------------------------
# get this information from the admin
api_url = ""
api_token = ""

# keeps the output clean
urllib3.disable_warnings()

#---------------------------------------------
# It's the main function... this is where we start
def main():
    # OpenCTI initialization
    opencti_api_client = OpenCTIApiClient(api_url, api_token)
    # Parse the command line arguments
    args = getargs()
    cryptoaddrs = []

    # file should be of the form (author is basically the source)
    # crypto address,malware,author,confidence
    if args['file']:
        lines = open(args['file']).readlines()
        for l in lines:
            f = l.split(',')
            if len(f) != 4:
                print('Why you giving me the wrong data? I want <crypto address>,<malware>,<author>,<confidence>')
                return
            cryptoaddrs.append({'addr':f[0], 'malware': f[1], 'author':f[2], 'confidence':f[3]})
    else:
        # bail if they don't provide an address
        if not args['addr']:
            print('We sort of need a crypto address here... try again with feeling')
            return
        cryptoaddrs.append({'addr':args['addr'], 'malware': args['malware'], 'author':args['author'], 'confidence':args['confidence']})

    
    for d in cryptoaddrs:

        # retrieve or create the cryptocurrency address
        cryptoaddr_observable = get_crypto_observable(opencti_api_client, d['addr'],d['author'],d['malware'],d['confidence'])
        # retrieve the malware or recommend the user have it created in db
        malware = get_malware(opencti_api_client,d['malware'])

        # if we have a crypto address and malware create an indicator and relationship
        if malware != None:
            create_relationship(opencti_api_client,cryptoaddr_observable,malware)

#----------------------------------------------
# Two modes of operation, either providing a single cryptocurrency address and malware name or
# a csv (todo). The submitter should provide an author, confidence and malware name.
# However, if no malware is provided it will default to a 'unknown' placeholder malware.
def getargs():
    parser = argparse.ArgumentParser(description='Send crypto address malware indicator to crypto community OpenCTI server. If you do not pass the malware name the cryptocurrency address will be associated with \'unknown\' malware. Please make sure you provide an author and confidence. Confidence will default to 50 if you do not.')
    parser.add_argument('-f','--file', help='Read cryptocurrency addresses from a csv file of format <crypto address>,<malware>,<author>,<confidence>', required=False)
    parser.add_argument('-d','--addr', help='Malicious cryptocurrency address to report', required=False)
    parser.add_argument('-m','--malware', help='The malware it indicates', required=False, default='unknown')
    parser.add_argument('-a','--author', help='Subitting org or individual (author)', required=False, default='SEAL')
    parser.add_argument('-c','--confidence', help='Confidence in relationship from 0 to 100', required=False, default='50')

    args = vars(parser.parse_args())

    return args

#--------------------------------
# You have a cryptocurrency address and some malware, create a relationship.
# In STIX the crypto addr can stand alone as an observable, so we
# create an indicator for the crypto addr that then establishes
# an 'indicates' relationship with the malware. It might
# seem overly complicated at first but trust the standard.
def create_relationship(opencti_api_client,addr,malware):
        
    # does a relationship already exist?
    found = False
    for i in addr['indicators']:
        # check if our crypto addr is in the pattern
        if 'pattern' in i and addr['value'] in i['pattern']:
            print("An indicator for this crypto addr already exists. Manually check the UI if the relationship it correct.")
            # technically a crypto addr could indicate multiple malware, but
            # for this iteration let's keep it simple and just return.
            found = True

    
    # Assuming there isn't already an indicator create a new one
    if not found:
        # an indicator can be a complex pattern, here the indicator is
        # just the presence of the crypto addr of interest
        indicator = opencti_api_client.indicator.create(
            name="{} associated with {}".format(addr['value'],malware['name']),
            description="{} associated with {}".format(addr['value'],malware['name']),
            pattern_type="stix",
            pattern="[cryptocurrency-wallet:value = '{}']".format(addr['value']),
            x_opencti_main_observable_type="Cryptocurrency-Wallet",
            valid_from=datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
        )

        # associate the indicator with the crypto addr observable
        opencti_api_client.indicator.add_stix_cyber_observable(
            id=indicator["id"], stix_cyber_observable_id=addr["id"]
        )

        # create the relationship
        relation = opencti_api_client.stix_core_relationship.create(
            fromId=indicator["id"],
            toId=malware["id"],
            relationship_type="indicates",
            description="{} associated with {}".format(addr['value'],malware['name']),
            start_time=datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
            #stop_time=datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
        )

#----------------------------
# If this crypto addr already exists in the db grab it, otherwise
# create it. Return a handle to a crypto observable object.
def get_crypto_observable(opencti_api_client, addr, author, malware, confidence):
    
    # search for the crypto address using filters
    observable = opencti_api_client.stix_cyber_observable.read(
        filters={
            "mode": "and",
            "filters": [{"key": "value", "values": [addr]}],
            "filterGroups": [],
        }
    )

    # didnt' find the crypto address, great create it!
    if observable == None:
        # Create crypto address observable
        opencti_api_client.stix_cyber_observable.create(
            observableData={
                "type": "Cryptocurrency-Wallet",
                "value": addr,
                "x_opencti_description": "Cryptocurrency address submitted by {} associated with {}".format(author,malware),
                "x_opencti_score": int(confidence),
            }
        )

        # for some reason when you create the observable you don't get back all the
        # data, so create it then search for it
        observable = opencti_api_client.stix_cyber_observable.read(
        filters={
            "mode": "and",
            "filters": [{"key": "value", "values": [addr]}],
            "filterGroups": [],
        }
    )
    
    # this should always contain a value since if it doesn't exist we create it
    return observable

#------------------------
# If this malware already exists in the db grab it, otherwise
# make some suggestions to the user. The intent here is that
# they select a known malware name and to reduce the chance of
# having the same malware with slight variations in the name.
# If you need a malware added just ping the OpenCTI admin
def get_malware(opencti_api_client,malware_name):

    # these filters are pretty generic
    malware = opencti_api_client.malware.read(
        filters = {
            "mode": "and",
            "filters": [{"key": "name", "values": [malware_name]}],
            "filterGroups": [],
        }
    )
    
    # found an exact match, great return it!
    if not malware == None:
        return malware
    else:
        # try to find similar matches
        malwares = opencti_api_client.malware.list(search=malware_name)
        # lots of similar matches, return a list so the user can try again
        if len(malwares) > 1:
            print('More then one match, please be more specific. Possible matches:')
            for m in malwares:
                print(m['name'])
        # if there is just one match, maybe it's a typo or an alias, provide a recommendation
        elif len(malwares) == 1 and malwares[0]['name'] != malware_name:
            print('Found possible match, please use this name: {}'.format(malwares[0]['name']))
        else:
            # You're way off, nothing like that in the db
            print('No matches found for malware, contact your admin to have it added')

    return None

#----------------------
# Do people still do this in Python? I feel weird if I don't have a "main"
if __name__ == '__main__':
    main()
